2015/06/10 エピローグ読了。何かわくわくしてきた
2015/06/10 clisp install。slimvも入れた。補完やインデントなどはslimvで実行はQuickRun/VimShellで十分そう
2015/06/10 1章を飛ばして2章へ。とりあえず1行でもコードを書いておきたいので
2015/06/10 [2章] defvarって再定義時にエラーにならないの怖い
2015/06/10 [2章] 2つの和の平均を整数で取りたいからと、2進法でbitをずらすのカッコいい
2015/06/10 [2章] flet, labelsは知らなかった。letと区別されるんだなってのと、fletいらなくないかという感(lablesでいいじゃん)
2015/06/12 [3章] 除算は分数になる。どちらかを少数にすると少数になる
2015/06/12 [3章] エスケープはダブルクオートとバックスラッシュだけらしい。タブ文字とかどうするんだろう
2015/06/12 [3章] コードモードとデータモードがある。コードモードはフォームと呼ばれる構造のリスト
2015/06/12 [3章] quoteしたデータを評価するのはevalでいいんかな？
2015/06/12 [3章] quoteにシングルクオートを使うから、文字列は必ずダブルクオートか
2015/06/12 [3章] 文字列とシンボルを比較したらtrueになるのか？評価結果はシンボルは大文字になるな
2015/06/12 [3章] コンスセルはドット(.)で区切られた評価結果になっている
2015/06/12 [3章] 空リストとnilは同じ
2015/06/12 [3章] コンスセルとリストは同じ
2015/06/12 [3章] cons/list/データ で作られたリストは全て同じ
2015/06/12 [3章] caddr とかは後ろから適用されて行く感じ(前からの方が読みやすくないか) cdr -> cdr -> car
2015/06/12 [3章] Lispのシンタックスはシンプルなのが特徴。でもcons/listとかやり方が色々あるのは複雑ではないか
2015/06/12 [4章] 空リストのみがfalse。0や空文字は? => true。再帰処理を行う上でその方が扱いやすいからだろうな
2015/06/12 [4章] 空リストは(), '(), nil, 'nilという複数の書き方がある
2015/06/12 [4章] ifの中で複数のことをしたければprognを使う。setfとか稀なケースか？単なる一時変数とかだとletで十分
2015/06/12 [4章] prognじゃなくてwhenやunlessでも良さそう。ただしこれらはelseがない
2015/06/12 [4章] 他のプログラミングにあるcase式に該当するのはcond。条件分岐多いなあ
2015/06/12 [4章] eqを行うcond => case
2015/06/12 [4章] 記載はないけどふと調べた事。labelsの変数版はlet*
2015/06/12 [4章] and/orを使った条件分岐のショートカット(and (x) (y) (func))は驚きだけど、可読性悪そう
2015/06/12 [4章] member関数が残りのリストを返す理由に納得。nilの場合の考慮かー
2015/06/12 [4章] 比較関数の狂気。eq/equal/equalpだけ覚えていれば良さそう
2015/06/13 [5章] ドキュメントはHyperSpecだ
2015/06/13 [5章] hash(連想リスト)のことをalistと呼ぶらしい
2015/06/13 [5章] assocはclojureにもあった気がする
2015/06/13 [5章] global変数を定義したが、関数ではちゃんと引数でもらうようになっているのか。状態としてglobalを使っているが関数とは疎結合にしているんだな
2015/06/13 [5章] 準クオート(`)は埋め込み文字列的なやつ
2015/06/13 [5章] シンボルのリストだから簡潔に書けただろう、とあるけど名前付き引数(hash)でも同じくらい簡潔かつその方が分かりやすいんじゃない?
2015/06/13 [5章] 英文的に(前から後ろに)読み進められないのはちょっと辛くないか？関数型だとそういうものかな。OOPのメソッドチェーンと異なる
2015/06/13 [5章] #'を使うのは名前空間が衝突するのを避けるため。それでも衝突する場合は最新(内側)の定義が使われる
2015/06/13 [5章] mapcarは「リストの各要素を1つずつfuncした新しいリストを返す」
2015/06/13 [5章] applyは「((x) (y))という構造に対して (func (x) (y)) という形でfunc適用する」
2015/06/13 [5章] リスト操作の雰囲気を味わえている。が、これが本当に強力なのか、メンテ性とかどうなのってあたりはまだ懐疑的
2015/06/13 [5章] object-locations、edgesみたいな構造にしていないのは何でだ
2015/06/13 [5章] remove-if-notって名前から破壊的操作に見えるけどそんなことはなかった。filterとかselectって名前にしてくれればいいのに
2015/06/13 [5章] lispの欲しい情報ってググりにくいな。「エラーメッセージを詳細に出したい」とか
2015/06/13 [5章] labelsの定義で括弧に惑わされてちょっとハマる
2015/06/14 [5章] やはりcarとかを使いこなすにはデータ構造を覚えておく必要があって大変な感じがある。他人が読む場合はもっと大変なのでは
2015/06/14 [5章] assocは最初に見つかった値を返すのか。全部返すわけじゃないんだ。docに`return the first cons in alist`と書いてあった
2015/06/14 [5章] push/assocを使ったこのやり方は手っ取り早いけど分かりにくいんじゃ...。->「Lisperがよく使うイディオム」らしい
2015/06/14 [5章] グローバル変数の構造は追々変わるかも？もしかしたら説明の都合上、今はこの構造でやっているのかもしれん
2015/06/15 [6章] タブ文字は#\tabだった。加えてprintではなくprincで出力する必要がある
2015/06/15 [6章] printとreadの対称性。printしたものはread出来るし逆もしかり。なのでprintの文字列出力はダブルクオートで囲まれているし、readで渡すときにはダブルクオートが必要。なるほど
2015/06/15 [6章] print/readとかevalとかで「Lispなら」みたいなドヤ顔されるけど、他の言語でも同様にコレぐらいはあるだろう
2015/06/15 [6章] データとコードの同図象性はLispらしさある
2015/06/16 [6章] (list 'quote "hoge") => '"hoge" になるのは何でだ。(list 'quote "hoge") => (quote "hoge") => '"hoge" ってことかな？最後が何で評価されるのか分からん。マクロだからか？
2015/06/16 [6章] (game-read)に大分時間を使ってしまった
2015/06/16 [6章] 引数のデータ構造が何か分からないのにcar/cdrを使いこなして行くのきつい気がする
2015/06/20 [6章] デバッグのやり方が分からないときつい。。。対話式のプログラムだとなおきつい
2015/06/20 [6章] 楽しいけど今のところ可読性があるとは思えず
2015/06/20 [6.5章] 無名関数とか高階関数は今なら多くの言語にあるのでドヤ顔されても、という感じはある
2015/06/20 [6.5章] 「lambdaがLispの根源であり、他の関数はlambdaの概念を元に導かれている」ってどういう意味だろう
2015/06/23 [7章] 終端がnil以外のものをドットリストというのか(1 2 . 3)
2015/06/23 [7章] ドットリストはpairなどを表現するのに便利。cdrでそのまま値が取れるので
2015/06/23 [7章] 循環リストを表示しようとするとそりゃ無限ループするか。*print-circle*
2015/06/23 [7章] 連想リスト(hash)のalistのaってassociateか
2015/06/23 [7章] alistの値を(表面上)変えるのはpushだけど、pushしているだけだから使う度にデータ量増えるよねこれ
2015/06/23 [7章] assocって普通のコンスセルには効かないのかな -> 出来た。((FOO 10) (...))っていう連想リストの形ならoKだ
2015/06/23 [7章] やっぱ効率的ではないらしい。(有用な他のデータ構造があるらしい)
2015/06/23 [7章] あ、やっぱりwizard-adventureで書いたデータ構造が分かりにくい(改善できる)、っていう話を取り上げるのね
2015/06/26 [7章] graphvizをinstallして使ってみる。ちょっと感動。関係ないけどsphinxを覚えたくなった
2015/06/26 [7章] #'関数名 で関数リファレンスを返すんだっけか
2015/06/26 [7章] complementすごいな
2015/06/26 [7章] -notで終わっている関数は非推奨らしい。substitue-if-notとか
2015/06/28 [7章] lispの関数って引数定義が多いよな...
2015/06/28 [7章] mapcarとmapcとかprintとprincとか覚えにくい
2015/06/28 [7章] 関数名に->とか入れちゃう辺りはLispって感じがする
2015/06/28 [7章] thunk(サンク)を使うテクニック。標準出力を切り離す。なるほど
2015/06/28 [7章] letやwith-open-fileで定義される変数やストリームは基本レキシカルだが、既にダイナミック変数としてある場合はそれを上書きする
2015/06/28 [7章] ダイナミック変数、用例を初めて見たかもしれない。こう言われると便利な側面もあるんだなあ。意図せず上書きするとかのバグが怖いけど
2015/07/09 [7章] 久々に書くとやはりデータ構造(car/cdr)の把握に詰まる。mapcarとか忘れていた
2015/07/16 [8章] 写経の要素が強くなりすぎてあまりコードの理解をしなくなってきているかもしれない
2015/07/16 [8章] collectしたものをappendしてる理由は何だろう？ -> (((1 2) (3 4)) ((5 6) (7 8)))みたいな構造をpairのlistとして平坦化するため ((1 2) (3 4) (5 6) (7 8))。nilも消せる
2015/07/16 [8章] loopの細かい記述が分からないけど10章で詳しく出るらしいのでここでは先に進む
2015/07/19 [8章] 4連休で一読するため理解度を下げて進める事を決心(あんま分かっていなくても写経を進める)
2015/07/19 [8章] 関数がほとんど理解出来ないのは「目的が分かっていない」のか「コードが読みにくい」のか果たして
2015/07/19 [8章] 8章はとりあえず写経だけして飛ばす
2015/07/19 [8章] clispのデバッグとしてbacktraceやtraceをやっと知った。Lispを勉強する上で一番の壁はデバッグ方法なのではないか
2015/07/19 [寄り道] replを直接使うのはおすすめしないという記事を見つけた...。slime(slimv)を使おうという話だったが、言語を覚えたいのに環境回りの勉強コストがかかるのは何かなあ。LispWorkは落とすのに入力項目があるのが嫌だ。Racket(DrRacket)はやはり良い
2015/07/19 [9章] setfすごいだろう的な話だが、他の言語でも似たようなことは出来るはず。a[1] = do {...} みたいなものだろう
2015/07/19 [9章] 値を取り出すコードとsetfが一緒に使われると、っていうところがポイントなのかな。その効力をまだ感じ取れていないけど
2015/07/19 [9章] setfの引数として複雑な式が書けるという事は、アクセスのための一時変数を置く必要がないということであり、宣言的に書けるという事ではあるな
2015/07/19 [9章] 配列やハッシュテーブルは性能が問題になってから、というのが著者のアドバイスらしい。特にハッシュテーブルはLisp的ではないのでデバッグがコンスセルより難しいから
2015/07/19 [9章] timesによる簡単なベンチマークいいね
2015/07/19 [9章] ハッシュテーブル早すぎ
2015/07/19 [9章] 配列もハッシュテーブルも構造体も(setf (xxxx) yyy)で値をセット出来るのは統一性があるか、な。ジェネリックなセッターとやらの効果
2015/07/19 [9章] 「構造体をいつ使うか」の議論は面白い
2015/07/19 [9章] シーケンスがあるからジェネリックな関数として扱える(Clojureの本でシーケンスについて何となく知っていたので助かる)
2015/07/19 [9章] 自前で複数の型に対応させるにはどうするか -> numberpとかで型を調べることは出来るがナンセンス -> defmethodがいい。Javaのoverload的な動きをする。動的言語でこれがサポートしてあるのって珍しいかも？
2015/07/19 [9章] ただ型を制限したところで落ちるのは実行時なわけだから微妙だよな(lispに限らず動的言語)。コンパイル時チェックで弾けるからこそのありがたみだと思う
2015/07/19 [9章] ゲーム回りのコードがつまらないのかも。思考の流れが分からないので単なる写経に近くなってしまっている
2015/07/19 [9章] オークバトルはワンプスよりコードを理解出来るが、やはり思考をトレース出来ないので写経の域を出ない。ゲームの仕様が最初に提示されず、コードが先行しているからか
2015/07/19 [9章] 書く場合の括弧の対応に結構慣れて来た。括弧のハイライトがないエディタだと無理だろうなコレ
2015/07/19 [9章] princで文字を繋げていくのだるい。formatの章で改善策が出るのかな
2015/07/19 [9章] defstructのincludeは継承っぽい
2015/07/19 [9章] defmethodを使う場合はデフォルト(型指定なし)の挙動を定義しておくといいのか
2015/07/19 [10章] loopは単なるfor文だと思ったら割と高機能だった。Scalaのfor式に近い
2015/07/19 [10章] loopマクロ多すぎ。組み込み関数(例:map,mapcar,mapcanとか)の時点で感じてはいたが、Lispの複雑性はこういうところにあるわ
2015/07/19 [10章] ゲーム写経をスキップする
2015/07/19 [10章] 何かLisp好きになれない感じがしてきた。Lisp系はいいけどCommonLispは合わない。概念だけ学ぶ事にしよう
2015/07/19 [11章] formatの制御シーケンス豊富だな。表を作れたり。記号だらけで見た目はカオスだけど
2015/07/19 [11章] formatでループを使えるのすごいな。キモい
2015/07/19 [12章] printにファイルストリーム渡したら書き込めるとかジェネリックでそういうところは好きなのに、何で関数の種類がこんな多いの。。。これがシンプルだったらかなり好きなのに
2015/07/19 [12章] with-open-file強力だな
2015/07/19 [12章] print/readでsocket通信出来るのカッコ良過ぎる...。しかもLispのデータ構造を何でも渡せるとか
2015/07/19 [12章] 文字列ストリームは他のストリームと差し替えてデバッグする時に有効とのこと。なるほど。あとは長い文字列を作るときは早い
2015/07/19 [12章] handler-caseでtry-catch的なことが出来る
2015/07/19 [12章] 関数を小さく切って動作確認しながら進めるのはいいな、と思ったけどテスト書きながら実装するだろうし当たり前な気もしてきた
2015/07/19 [12章] 各処理を読み取れてはいるのだけど、リスト処理や再帰処理のコツが学べている感じはしない
2015/07/19 [12章] ソケットストリームの変わりに文字列ストリームを渡してテストするのカッコいい
2015/07/19 [12章] key/valueの取り出しが結局car/cdrなの分かり辛い。データ構造を把握していないと読み進められないということになる
2015/07/19 [12章] サーバーを起動しなくてもハンドラのテストを書けるのは便利
2015/08/10 [15章] 久々に書いている
2015/08/10 [15章] 0/1をプレイヤーに見立てるとか分かりにく過ぎるだろ。あとで変えるのかな
2015/08/10 [15章] 久々に書くと組み込み関数とかloopなどの構文を忘れている。カッコはもう慣れたっぽい
2015/08/10 [15章] だんだんコードの意味をあまり理解せず写経するだけになってきている
2015/08/12 [15章] 同上。ロジックが分かっていないのかな
